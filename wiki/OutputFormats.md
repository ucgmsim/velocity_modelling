# Output Formats in NZCVM

This page provides detailed information about the output formats generated by the NZCVM, including the EMOD3D format and CSV files.

## EMOD3D Format

The EMOD3D format is the primary output format of the NZCVM. It is used by the EMOD3D finite difference wave propagation code for earthquake ground motion simulations.

### File Structure

The EMOD3D output consists of three binary files: 
- `vp3dfile.p`: P-wave velocity values
- `vs3dfile.s`: S-wave velocity values
- `rho3dfile.d`: Density values
- `in_basin_mask.b`: Basin membership (ie. ID of the basin the grid point belongs to. -1 indicates not inside any basin)

Each file contains a 3D grid of values in a binary format, with values arranged in column-major order (Fortran order).

### Header Information

The header information for the model is stored in a separate text file named `<model_name>.info`. This file contains:

```
hh: Grid spacing (in kilometers)
nx, ny, nz: Number of grid points in x, y, and z directions
modellon, modellat: Longitude and latitude of the model origin
modelrot: Rotation angle of the model grid (in degrees)
topo_type: Type of topography used (BULLDOZED, SQUASHED, etc.)
```

### Reading EMOD3D Files

Here's an example of how to read EMOD3D files in Python:

```python
import numpy as np

def read_emod3d_file(filename, nx, ny, nz):
    """
    Read an EMOD3D binary file.
    
    Parameters:
    filename (str): Path to the EMOD3D file
    nx, ny, nz (int): Grid dimensions
    
    Returns:
    numpy.ndarray: 3D array of values
    """
    with open(filename, 'rb') as f:
        data = np.fromfile(f, dtype=np.float32)
    
    # Reshape to 3D grid (Fortran order)
    data = data.reshape((nx, ny, nz), order='F')
    
    return data

# Read header information
with open('model.info', 'r') as f:
    lines = f.readlines()
    hh = float(lines[0].strip())
    nx, ny, nz = map(int, lines[1].strip().split())
    modellon, modellat = map(float, lines[2].strip().split())
    modelrot = float(lines[3].strip())
    topo_type = lines[4].strip()

# Read velocity and density files
vp = read_emod3d_file('model.v_p', nx, ny, nz)
vs = read_emod3d_file('model.v_s', nx, ny, nz)
rho = read_emod3d_file('model.rho', nx, ny, nz)
```

## CSV Format

In addition to the EMOD3D format, the NZCVM can also output velocity models in CSV format for easier inspection and analysis.

### Format Specification

The CSV output contains one row per grid point, with the following columns:
- `x`, `y`, `z`: Grid coordinates (in kilometers)
- `lon`, `lat`, `depth`: Geographic coordinates
- `vp`: P-wave velocity (in meters per second)
- `vs`: S-wave velocity (in meters per second)
- `rho`: Density (in kilograms per cubic meter)

### Example

```
x,y,z,lon,lat,depth,vp,vs,rho
0.0,0.0,0.0,172.5000,-43.5000,0.0,1500.0,500.0,2000.0
0.2,0.0,0.0,172.5020,-43.5000,0.0,1520.0,510.0,2010.0
0.4,0.0,0.0,172.5040,-43.5000,0.0,1540.0,520.0,2020.0
...
```

### Reading CSV Files

CSV files can be easily read using standard libraries in most programming languages. Here's an example in Python:

```python
import pandas as pd

# Read CSV file
df = pd.read_csv('model.csv')

# Get velocity values at a specific location
x, y, z = 1.0, 2.0, 0.5
point = df[(df['x'] == x) & (df['y'] == y) & (df['z'] == z)]
vp = point['vp'].values[0]
vs = point['vs'].values[0]
rho = point['rho'].values[0]
```

HDF5 (Hierarchical Data Format version 5) is an efficient binary format for storing large scientific datasets with metadata. This format offers several advantages:

- **Single consolidated file**: All velocity model data is stored in one file
- **Efficient storage with compression**: Reduces file size compared to uncompressed formats
- **Self-describing format with embedded metadata**: Units, model version, and other metadata stored with the data
- **High-performance I/O**: Supports fast reading of specific data regions
- **Cross-platform compatibility**: Works across different operating systems and environments
- **Supports parallel I/O**: Beneficial for high-performance computing applications

### Using HDF5 Format

To generate a velocity model in HDF5 format:

```bash
nzvm generate-velocity-model /path/to/nzvm.cfg --output-format HDF5
```

### HDF5 File Structure

The HDF5 output consists of a single file:
- Location: `<output_dir>/velocity_model.h5`

The file structure is organized as follows:

- **Root attributes**:
  - `total_y_slices`: Total number of latitude slices in the model
  - `format_version`: Version of the HDF5 format specification
  - `complete`: Boolean flag indicating if the model is complete
  - `model_version`: Version of the velocity model being used

- **`/mesh` group**:
  - `x`: Array of X coordinates (km)
  - `y`: Array of Y coordinates (km) 
  - `z`: Array of Z (depth) coordinates (km)
  - `lon`: 2D array of longitude values
  - `lat`: 2D array of latitude values

- **`/properties` group**:
  - `vp`: 3D array of P-wave velocities (km/s) [shape: (nx, ny, nz)]
  - `vs`: 3D array of S-wave velocities (km/s) [shape: (nx, ny, nz)]
  - `rho`: 3D array of densities (g/cmÂ³) [shape: (nx, ny, nz)]
  - `inbasin`: 3D array of basin membership flags [shape: (nx, ny, nz)]

Each property dataset includes attributes describing units and constraints (e.g., minimum Vs values).

### Reading HDF5 Files

The generated HDF5 files can be easily accessed using various programming languages:

**Python example:**
```python
import h5py
import numpy as np
import matplotlib.pyplot as plt

# Open the HDF5 file
with h5py.File('velocity_model.h5', 'r') as f:
    # Access metadata
    model_version = f.attrs.get('model_version', 'unknown')
    print(f"Model version: {model_version}")
    
    # Get depth slice of Vs at a specific depth index
    vs = f['properties/vs'][:, :, 100]  # depth slice at index 100
    
    # Get coordinates
    x = f['mesh/x'][:]
    y = f['mesh/y'][0]  # y values are repeated, just take first set
    
    # Create a plot
    plt.figure(figsize=(10, 8))
    plt.pcolormesh(x, y, vs.T, shading='auto', cmap='viridis')
    plt.colorbar(label='Vs (km/s)')
    plt.title(f'S-wave velocity at depth slice 100 - Model v{model_version}')
    plt.xlabel('X (km)')
    plt.ylabel('Y (km)')
    plt.savefig('vs_slice.png')
```
### ParaView Visualization

To visualize the HDF5 model in ParaView:

1. Open ParaView
2. Use "File > Open" and select the generated XDMF file (`velocity_model.xdmf`)
3. Click "Apply" in the Properties panel
4. Use the "Slice" filter to create cross-sections of the model

For HDF5 files without an XDMF companion:

1. Use "File > Open" and select the HDF5 file
2. In the Properties panel, select "XDMF Reader" or "HDF5 Raw Reader"
3. Manually specify the dimensions and coordinate information:
   - Select the datasets for x, y, and z coordinates
   - Select the property datasets (vp, vs, rho) as point data
4. Click "Apply" and proceed with visualization

## Other Output Files

Depending on the configuration, the NZCVM may also generate additional output files:

- **Log files**: Contains information about the model generation process, including any warnings or errors.
- **Visualization files**: For visualization in tools like PyVista or ParaView.
- **Metadata files**: JSON or YAML files containing metadata about the generated model.

## Output Location

By default, output files are stored in the directory specified by the `--out-dir` argument when running the `nzvm.py` script. If not specified, they are stored in the directory specified by the `OUTPUT_DIR` parameter in the configuration file.

Each model version and configuration creates a separate subdirectory to avoid overwriting existing files.
